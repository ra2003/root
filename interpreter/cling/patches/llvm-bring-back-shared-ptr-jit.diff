diff --git a/include/llvm/ExecutionEngine/ExecutionEngine.h b/include/llvm/ExecutionEngine/ExecutionEngine.h
index 969f141f242..4fb6dad9638 100644
--- a/include/llvm/ExecutionEngine/ExecutionEngine.h
+++ b/include/llvm/ExecutionEngine/ExecutionEngine.h
@@ -131,7 +131,7 @@ class ExecutionEngine {
 protected:
   /// The list of Modules that we are JIT'ing from.  We use a SmallVector to
   /// optimize for the case where there is only one module.
-  SmallVector<std::shared_ptr<Module>, 1> Modules;
+  SmallVector<std::unique_ptr<Module>, 1> Modules;
 
   /// getMemoryforGV - Allocate memory for a global variable.
   virtual char *getMemoryForGV(const GlobalVariable *GV);
@@ -170,7 +170,7 @@ public:
   virtual ~ExecutionEngine();
 
   /// Add a Module to the list of modules that we can JIT from.
-  virtual void addModule(std::shared_ptr<Module> M) {
+  virtual void addModule(std::unique_ptr<Module> M) {
     Modules.push_back(std::move(M));
   }
 
diff --git a/include/llvm/ExecutionEngine/Orc/CompileOnDemandLayer.h b/include/llvm/ExecutionEngine/Orc/CompileOnDemandLayer.h
index 75e9e78d75d..5f593a27cad 100644
--- a/include/llvm/ExecutionEngine/Orc/CompileOnDemandLayer.h
+++ b/include/llvm/ExecutionEngine/Orc/CompileOnDemandLayer.h
@@ -192,7 +192,7 @@ private:
 
   struct LogicalDylib {
     struct SourceModuleEntry {
-      std::shared_ptr<Module> SourceMod;
+      std::unique_ptr<Module> SourceMod;
       std::set<Function*> StubsToClone;
     };
 
@@ -206,7 +206,7 @@ private:
         : K(std::move(K)), BackingResolver(std::move(BackingResolver)),
           StubsMgr(std::move(StubsMgr)) {}
 
-    SourceModuleHandle addSourceModule(std::shared_ptr<Module> M) {
+    SourceModuleHandle addSourceModule(std::unique_ptr<Module> M) {
       SourceModuleHandle H = SourceModules.size();
       SourceModules.push_back(SourceModuleEntry());
       SourceModules.back().SourceMod = std::move(M);
@@ -298,7 +298,7 @@ public:
   }
 
   /// Add a module to the compile-on-demand layer.
-  Error addModule(VModuleKey K, std::shared_ptr<Module> M) {
+  Error addModule(VModuleKey K, std::unique_ptr<Module> M) {
 
     assert(!LogicalDylibs.count(K) && "VModuleKey K already in use");
     auto I = LogicalDylibs.insert(
@@ -310,7 +310,7 @@ public:
   }
 
   /// Add extra modules to an existing logical module.
-  Error addExtraModule(VModuleKey K, std::shared_ptr<Module> M) {
+  Error addExtraModule(VModuleKey K, std::unique_ptr<Module> M) {
     return addLogicalModule(LogicalDylibs[K], std::move(M));
   }
 
@@ -376,7 +376,7 @@ public:
   }
 
 private:
-  Error addLogicalModule(LogicalDylib &LD, std::shared_ptr<Module> SrcMPtr) {
+  Error addLogicalModule(LogicalDylib &LD, std::unique_ptr<Module> SrcMPtr) {
 
     // Rename anonymous globals and promote linkage to ensure that everything
     // will resolve properly after we partition SrcM.
diff --git a/include/llvm/ExecutionEngine/Orc/IRCompileLayer.h b/include/llvm/ExecutionEngine/Orc/IRCompileLayer.h
index 70e336d20cd..52223a83ad4 100644
--- a/include/llvm/ExecutionEngine/Orc/IRCompileLayer.h
+++ b/include/llvm/ExecutionEngine/Orc/IRCompileLayer.h
@@ -59,7 +59,7 @@ class LegacyIRCompileLayer {
 public:
   /// Callback type for notifications when modules are compiled.
   using NotifyCompiledCallback =
-      std::function<void(VModuleKey K, std::shared_ptr<Module>)>;
+      std::function<void(VModuleKey K, std::unique_ptr<Module>)>;
 
   /// Construct an LegacyIRCompileLayer with the given BaseLayer, which must
   ///        implement the ObjectLayer concept.
@@ -89,7 +89,7 @@ public:
 
   /// Compile the module, and add the resulting object to the base layer
   ///        along with the given memory manager and symbol resolver.
-  Error addModule(VModuleKey K, std::shared_ptr<Module> M) {
+  Error addModule(VModuleKey K, std::unique_ptr<Module> M) {
     if (auto Err = BaseLayer.addObject(std::move(K), Compile(*M)))
       return Err;
     if (NotifyCompiled)
diff --git a/include/llvm/ExecutionEngine/Orc/LazyEmittingLayer.h b/include/llvm/ExecutionEngine/Orc/LazyEmittingLayer.h
index ea3d46348c9..16202d89f86 100644
--- a/include/llvm/ExecutionEngine/Orc/LazyEmittingLayer.h
+++ b/include/llvm/ExecutionEngine/Orc/LazyEmittingLayer.h
@@ -42,8 +42,8 @@ template <typename BaseLayerT> class LazyEmittingLayer {
 private:
   class EmissionDeferredModule {
   public:
-    EmissionDeferredModule(VModuleKey K, std::shared_ptr<Module> M)
-        : K(std::move(K)), M(M) {}
+    EmissionDeferredModule(VModuleKey K, std::unique_ptr<Module> M)
+        : K(std::move(K)), M(std::move(M)) {}
 
     JITSymbol find(StringRef Name, bool ExportedSymbolsOnly, BaseLayerT &B) {
       switch (EmitState) {
@@ -186,12 +186,12 @@ private:
 
     enum { NotEmitted, Emitting, Emitted } EmitState = NotEmitted;
     VModuleKey K;
-    std::shared_ptr<Module> M;
+    std::unique_ptr<Module> M;
     mutable std::unique_ptr<StringMap<const GlobalValue*>> MangledSymbols;
   };
 
   BaseLayerT &BaseLayer;
-  std::map<VModuleKey, std::shared_ptr<EmissionDeferredModule>> ModuleMap;
+  std::map<VModuleKey, std::unique_ptr<EmissionDeferredModule>> ModuleMap;
 
 public:
 
@@ -206,10 +206,10 @@ public:
       : BaseLayer(BaseLayer) {}
 
   /// Add the given module to the lazy emitting layer.
-  Error addModule(VModuleKey K, std::shared_ptr<Module> M) {
+  Error addModule(VModuleKey K, std::unique_ptr<Module> M) {
     assert(!ModuleMap.count(K) && "VModuleKey K already in use");
     ModuleMap[K] =
-        std::make_shared<EmissionDeferredModule>(std::move(K), std::move(M));
+        llvm::make_unique<EmissionDeferredModule>(std::move(K), std::move(M));
     return Error::success();
   }
 
diff --git a/lib/ExecutionEngine/ExecutionEngine.cpp b/lib/ExecutionEngine/ExecutionEngine.cpp
index dfbe3025923..1c6c0406d04 100644
--- a/lib/ExecutionEngine/ExecutionEngine.cpp
+++ b/lib/ExecutionEngine/ExecutionEngine.cpp
@@ -144,6 +144,7 @@ bool ExecutionEngine::removeModule(Module *M) {
   for (auto I = Modules.begin(), E = Modules.end(); I != E; ++I) {
     Module *Found = I->get();
     if (Found == M) {
+      I->release();
       Modules.erase(I);
       clearGlobalMappingsFromModule(M);
       return true;
@@ -407,7 +408,7 @@ void ExecutionEngine::runStaticConstructorsDestructors(Module &module,
 
 void ExecutionEngine::runStaticConstructorsDestructors(bool isDtors) {
   // Execute global ctors/dtors for each module in the program.
-  for (std::shared_ptr<Module> &M : Modules)
+  for (std::unique_ptr<Module> &M : Modules)
     runStaticConstructorsDestructors(*M, isDtors);
 }
 
diff --git a/lib/ExecutionEngine/Orc/OrcCBindingsStack.h b/lib/ExecutionEngine/Orc/OrcCBindingsStack.h
index 5afda2826a9..98129e1690d 100644
--- a/lib/ExecutionEngine/Orc/OrcCBindingsStack.h
+++ b/lib/ExecutionEngine/Orc/OrcCBindingsStack.h
@@ -283,7 +283,7 @@ public:
 
   template <typename LayerT>
   Expected<orc::VModuleKey>
-  addIRModule(LayerT &Layer, std::shared_ptr<Module> M,
+  addIRModule(LayerT &Layer, std::unique_ptr<Module> M,
               std::unique_ptr<RuntimeDyld::MemoryManager> MemMgr,
               LLVMOrcSymbolResolverFn ExternalResolver,
               void *ExternalResolverCtx) {
@@ -322,7 +322,7 @@ public:
   }
 
   Expected<orc::VModuleKey>
-  addIRModuleEager(std::shared_ptr<Module> M,
+  addIRModuleEager(std::unique_ptr<Module> M,
                    LLVMOrcSymbolResolverFn ExternalResolver,
                    void *ExternalResolverCtx) {
     return addIRModule(CompileLayer, std::move(M),
@@ -331,7 +331,7 @@ public:
   }
 
   Expected<orc::VModuleKey>
-  addIRModuleLazy(std::shared_ptr<Module> M,
+  addIRModuleLazy(std::unique_ptr<Module> M,
                   LLVMOrcSymbolResolverFn ExternalResolver,
                   void *ExternalResolverCtx) {
     if (!CODLayer)
diff --git a/lib/ExecutionEngine/Orc/OrcMCJITReplacement.h b/lib/ExecutionEngine/Orc/OrcMCJITReplacement.h
index 9bb081f7cd8..169dc8f1d02 100644
--- a/lib/ExecutionEngine/Orc/OrcMCJITReplacement.h
+++ b/lib/ExecutionEngine/Orc/OrcMCJITReplacement.h
@@ -246,7 +246,7 @@ public:
             NotifyObjectLoaded, NotifyFinalized),
         CompileLayer(AcknowledgeORCv1Deprecation, ObjectLayer,
                      SimpleCompiler(*this->TM),
-                     [this](VModuleKey K, std::shared_ptr<Module> M) {
+                     [this](VModuleKey K, std::unique_ptr<Module> M) {
                        Modules.push_back(std::move(M));
                      }),
         LazyEmitLayer(AcknowledgeORCv1Deprecation, CompileLayer) {}
@@ -255,7 +255,7 @@ public:
     OrcMCJITReplacementCtor = createOrcMCJITReplacement;
   }
 
-  void addModule(std::shared_ptr<Module> M) override {
+  void addModule(std::unique_ptr<Module> M) override {
     // If this module doesn't have a DataLayout attached then attach the
     // default.
     if (M->getDataLayout().isDefault()) {
@@ -292,7 +292,7 @@ public:
     UnexecutedConstructors[K] = std::move(CtorNames);
     UnexecutedDestructors[K] = std::move(DtorNames);
 
-    cantFail(LazyEmitLayer.addModule(K, M));
+    cantFail(LazyEmitLayer.addModule(K, std::move(M)));
   }
 
   void addObjectFile(std::unique_ptr<object::ObjectFile> O) override {
